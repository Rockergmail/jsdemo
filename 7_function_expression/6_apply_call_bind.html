<!DOCTYPE html>
<html lang="zh-cmn-Hans">
<head>
<meta charset="utf-8" />
<title></title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>
<script>
/*
apply,call
*/
var func=function(arg1,arg2){};
func.call(this,'arg1','arg2');
func.apply(this,['arg1','arg2']);
/*
当你的参数是明确知道数量时用 call 。
而不确定的时候用 apply，然后把参数 push 进数组传递进去。
当参数数量不确定时，函数内部也可以通过 arguments 这个数组来遍历所有的参数。
*/

//例子一：
function Fruits(){}
Fruits.prototype={
	color:'red',
	say:function(){
		console.log("My color is "+this.color);
	}
}

var apple=new Fruits();
apple.say(); //red, this->apple

var banana={color:'yellow'};
apple.say.call(banana); //yellow, this->banana
apple.say.apply(banana);  //yellow, this->banana

//例子二：
var array1=[12,'foo',{name:'Rocker'},-2458];
var array2=['Winty',555,100];
Array.prototype.push.apply(array1,array2);//this->array1,参数是一个数组->array2
console.log(array1); 
//[12, "foo", Object, -2458, "Winty", 555, 100]

//例子三：
var numbers=[5,458,120,-215];
var maxInNumbers=Math.max.apply(Math,numbers);
console.log(Math.max(numbers));//NaN，因为这样调用的话，参入参数应该时Math.max(1,2,3)，而不是传入一个数组。所以如果你要传入一个数组，就要用上面那种方式
console.log(maxInNumbers);
var maxInNumbers=Math.max.call(Math,5,458,120,-215);
console.log(maxInNumbers);
var b=[1,2,3];
console.log(b.toString());

//深入理解运用，定义了一个log方法，代理console.log方法
function log(msg){ console.log(msg); }
log(1);  //1
log(1,2);  //1
//缺点，只能输出一个
//解决方法：
function log2(msg){ console.log.apply(console,arguments)}
log2(1,2); //1 2


//bind
//多次 bind() 是无效的,只承认第一次的调用。更深层次的原因， bind() 的实现，相当于使用函数在内部包了一个 call / apply ，第二次 bind() 相当于再包住第一次 bind() ,故第二次以后的 bind 是无法生效的。


//apply,call,bind的比较
var obj={x:81,};
var foo={
	getX:function(){
		return this.x;
	}
}

console.log(foo.getX.call(obj));
console.log(foo.getX.apply(obj));
console.log(foo.getX.bind(obj)());

/*
apply 、 call 、bind 三者都是用来改变函数的this对象的指向的；
apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文；
apply 、 call 、bind 三者都可以利用后续参数传参；
bind 是返回对应函数，便于稍后调用；apply 、call则是立即调用。
*/
</script>
</body>
</html>
